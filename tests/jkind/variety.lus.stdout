Core Lustre
===========

node (delta_x : int, delta_y : int)
  returns ()
  assumes (Leq, Leq$1)
  shows (cex1, ok1)
let
  pre_p1.x : int
    = pre p1.x
   
  init_pre_p1.x : int
    = 0 -> pre_p1.x
   
  p1.x : int
    = Add(init_pre_p1.x, delta_x)
   
  pre_p1.y : int
    = pre p1.y
   
  init_pre_p1.y : int
    = 0 -> pre_p1.y
   
  p1.y : int
    = Add(init_pre_p1.y, delta_y)
   
  pre_p2.x : int
    = pre p2.x
   
  p.x : int
    = 0 -> pre_p2.x
   
  delta.x : int
    = delta_x
   
  q.x : int
    = delta.x
   
  x_coord : int
    = Add(p.x, q.x)
   
  p2.x : int
    = x_coord
   
  pre_p2.y : int
    = pre p2.y
   
  p.y : int
    = 0 -> pre_p2.y
   
  delta.y : int
    = delta_y
   
  q.y : int
    = delta.y
   
  y_coord : int
    = Add(p.y, q.y)
   
  p2.y : int
    = y_coord
   
  ok1 : bool
    = And(Eq(p1.x, p2.x), Eq(p1.y, p2.y))
   
  cex1 : bool
    = Or(Neq(p1.x, 20), Neq(p1.y, 13))
   
  z$1 : int
    = delta_x
   
  abs$1 : int
    = ITE(Geq(z$1, 0), z$1, Neg(z$1))
   
  z : int
    = delta_y
   
  abs : int
    = ITE(Geq(z, 0), z, Neg(z))
   
  Leq$1 : bool
    = Leq(abs$1, 2)
   
  Leq : bool
    = Leq(abs, 2)
tel
Sally Model
===========

(define-state-type
   S
   (
     (Leq Bool)
     (abs Int)
     (cex1 Bool)
     (ok1 Bool)
     (z Int)
     (|Leq:1| Bool)
     (|abs:1| Int)
     (|delta.x| Int)
     (|delta.y| Int)
     (|delta_x| Int)
     (|delta_y| Int)
     (|gal-initializing| Bool)
     (|init_pre_p1.x:init| Bool)
     (|init_pre_p1.x| Int)
     (|init_pre_p1.y:init| Bool)
     (|init_pre_p1.y| Int)
     (|p.x:init| Bool)
     (|p.x| Int)
     (|p.y:init| Bool)
     (|p.y| Int)
     (|p1.x| Int)
     (|p1.y| Int)
     (|p2.x| Int)
     (|p2.y| Int)
     (|pre_p1.x| Int)
     (|pre_p1.y| Int)
     (|pre_p2.x| Int)
     (|pre_p2.y| Int)
     (|q.x| Int)
     (|q.y| Int)
     (|x_coord| Int)
     (|y_coord| Int)
     (|z:1| Int))
   (
     (|delta_x| Int)
     (|delta_y| Int)))
(define-transition-system
   TS
   S
   (and
      (= |gal-initializing| true)
      (= |init_pre_p1.x:init| true)
      (= |init_pre_p1.y:init| true)
      (= |p.x:init| true)
      (= |p.y:init| true))
   (and
      (= next.|gal-initializing| false)
      (= next.|delta_x| input.|delta_x|)
      (= next.|delta_y| input.|delta_y|)
      next.Leq
      next.|Leq:1|
      (= next.|pre_p1.x| state.|p1.x|)
      (ite
         state.|init_pre_p1.x:init|
         (= next.|init_pre_p1.x| 0)
         (= next.|init_pre_p1.x| next.|pre_p1.x|))
      (= next.|init_pre_p1.x:init| false)
      (=
         next.|p1.x|
         (+ next.|init_pre_p1.x| next.|delta_x|))
      (= next.|pre_p1.y| state.|p1.y|)
      (ite
         state.|init_pre_p1.y:init|
         (= next.|init_pre_p1.y| 0)
         (= next.|init_pre_p1.y| next.|pre_p1.y|))
      (= next.|init_pre_p1.y:init| false)
      (=
         next.|p1.y|
         (+ next.|init_pre_p1.y| next.|delta_y|))
      (= next.|pre_p2.x| state.|p2.x|)
      (ite
         state.|p.x:init|
         (= next.|p.x| 0)
         (= next.|p.x| next.|pre_p2.x|))
      (= next.|p.x:init| false)
      (= next.|delta.x| next.|delta_x|)
      (= next.|q.x| next.|delta.x|)
      (=
         next.|x_coord|
         (+ next.|p.x| next.|q.x|))
      (= next.|p2.x| next.|x_coord|)
      (= next.|pre_p2.y| state.|p2.y|)
      (ite
         state.|p.y:init|
         (= next.|p.y| 0)
         (= next.|p.y| next.|pre_p2.y|))
      (= next.|p.y:init| false)
      (= next.|delta.y| next.|delta_y|)
      (= next.|q.y| next.|delta.y|)
      (=
         next.|y_coord|
         (+ next.|p.y| next.|q.y|))
      (= next.|p2.y| next.|y_coord|)
      (=
         next.ok1
         (and
            (= next.|p1.x| next.|p2.x|)
            (= next.|p1.y| next.|p2.y|)))
      (=
         next.cex1
         (or
            (not
               (= next.|p1.x| 20))
            (not
               (= next.|p1.y| 13))))
      (= next.|z:1| next.|delta_x|)
      (=
         next.|abs:1|
         (ite
            (<= 0 next.|z:1|)
            next.|z:1|
            (- next.|z:1|)))
      (= next.z next.|delta_y|)
      (=
         next.abs
         (ite
            (<= 0 next.z)
            next.z
            (- next.z)))
      (=
         next.|Leq:1|
         (<= next.|abs:1| 2))
      (=
         next.Leq
         (<= next.abs 2))))

(query
   TS
   (or |gal-initializing| cex1))
(query
   TS
   (or |gal-initializing| ok1))

[Lustre] Validating properties:
[Lustre] Property cex1... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
considering simultaneous states to depth 1
considering simultaneous states to depth 2
considering simultaneous states to depth 2
considering simultaneous states to depth 3
considering simultaneous states to depth 3
considering simultaneous states to depth 4
considering simultaneous states to depth 4
considering simultaneous states to depth 5
considering simultaneous states to depth 5
considering simultaneous states to depth 6
considering simultaneous states to depth 6
considering simultaneous states to depth 7
considering simultaneous states to depth 7
considering simultaneous states to depth 8
considering simultaneous states to depth 8
considering simultaneous states to depth 9
considering simultaneous states to depth 9
considering simultaneous states to depth 10
[Invalid] 
Trace
=====

cex1:
 Step | delta_x | delta_y | |-> 
------+---------+---------+-----
 1    | 2       | 2       |     
 2    | 2       | 2       |     
 3    | 2       | 2       |     
 4    | 2       | 2       |     
 5    | 2       | 2       |     
 6    | 2       | 2       |     
 7    | 2       | 2       |     
 8    | 2       | -1      |     
 9    | 2       | 0       |     
 10   | 2       | 0       |     

[Lustre] Property ok1... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
considering simultaneous states to depth 1
[Valid] considering simultaneous states to depth 1
[Lustre] Model status: [Invalid] 
