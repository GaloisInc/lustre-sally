Core Lustre
===========

node (x : int, s : int)
  returns ()
  assumes ()
  shows (ok4, ok3, ok2, cex1, ok1)
let
  valof_pre_valof_arr$4 = pre valof_arr$4
  y = 1 -> valof_pre_valof_arr$4
  valof_pre_z2 = pre z2
  z1 = 1 -> valof_pre_z2
  valof_pre_x$1 = pre x
  z2 = 2 -> valof_pre_x$1
  valof_pre_valof_arr$3 = pre valof_arr
  w = 1 -> valof_pre_valof_arr$3
  ok1 = Eq(y, z1)
  valof_pre_s$1 = pre s
  valof_pre_s = pre s
  ok2 = And(Leq(0, valof_pre_s$1), Leq(valof_pre_s, 1))
  pre_s = pre s
  ok3 = And(Leq(0, pre_s), Leq(pre_s, 1))
  r = pre r
  ok4 = And(Leq(0, r), Leq(r, 1))
  cex1 = Lt(w, 6)
  valof_pre_x = pre x
  valof_arr$4 = 2 -> valof_pre_x
  valof_arr$3 = 5 -> 6
  valof_pre_valof_arr$2 = pre valof_arr$3
  valof_arr$2 = 4 -> valof_pre_valof_arr$2
  valof_pre_valof_arr$1 = pre valof_arr$2
  valof_arr$1 = 3 -> valof_pre_valof_arr$1
  valof_pre_valof_arr = pre valof_arr$1
  valof_arr = 2 -> valof_pre_valof_arr
tel
Sally Model
===========

(define-state-type
   S
   (
     (cex1 Bool)
     (ok1 Bool)
     (ok2 Bool)
     (ok3 Bool)
     (ok4 Bool)
     (r Int)
     (s Int)
     (w Int)
     (x Int)
     (y Int)
     (z1 Int)
     (z2 Int)
     (|gal-initializing| Bool)
     (|pre_s| Int)
     (|valof_arr:1:init| Bool)
     (|valof_arr:1| Int)
     (|valof_arr:2:init| Bool)
     (|valof_arr:2| Int)
     (|valof_arr:3:init| Bool)
     (|valof_arr:3| Int)
     (|valof_arr:4:init| Bool)
     (|valof_arr:4| Int)
     (|valof_arr:init| Bool)
     (|valof_arr| Int)
     (|valof_pre_s:1| Int)
     (|valof_pre_s| Int)
     (|valof_pre_valof_arr:1| Int)
     (|valof_pre_valof_arr:2| Int)
     (|valof_pre_valof_arr:3| Int)
     (|valof_pre_valof_arr:4| Int)
     (|valof_pre_valof_arr| Int)
     (|valof_pre_x:1| Int)
     (|valof_pre_x| Int)
     (|valof_pre_z2| Int)
     (|w:init| Bool)
     (|y:init| Bool)
     (|z1:init| Bool)
     (|z2:init| Bool))
   (
     (s Int)
     (x Int)))
(define-transition-system
   TS
   S
   (and
      (= |gal-initializing| true)
      (= |y:init| true)
      (= |z1:init| true)
      (= |z2:init| true)
      (= |w:init| true)
      (= |valof_arr:4:init| true)
      (= |valof_arr:3:init| true)
      (= |valof_arr:2:init| true)
      (= |valof_arr:1:init| true)
      (= |valof_arr:init| true))
   (and
      (= next.|gal-initializing| false)
      (= next.x input.x)
      (= next.s input.s)
      (= next.|valof_pre_valof_arr:4| state.|valof_arr:4|)
      (ite
         state.|y:init|
         (= next.y 1)
         (= next.y next.|valof_pre_valof_arr:4|))
      (= next.|y:init| false)
      (= next.|valof_pre_z2| state.z2)
      (ite
         state.|z1:init|
         (= next.z1 1)
         (= next.z1 next.|valof_pre_z2|))
      (= next.|z1:init| false)
      (= next.|valof_pre_x:1| state.x)
      (ite
         state.|z2:init|
         (= next.z2 2)
         (= next.z2 next.|valof_pre_x:1|))
      (= next.|z2:init| false)
      (= next.|valof_pre_valof_arr:3| state.|valof_arr|)
      (ite
         state.|w:init|
         (= next.w 1)
         (= next.w next.|valof_pre_valof_arr:3|))
      (= next.|w:init| false)
      (=
         next.ok1
         (= next.y next.z1))
      (= next.|valof_pre_s:1| state.s)
      (= next.|valof_pre_s| state.s)
      (=
         next.ok2
         (and
            (<= 0 next.|valof_pre_s:1|)
            (<= next.|valof_pre_s| 1)))
      (= next.|pre_s| state.s)
      (=
         next.ok3
         (and
            (<= 0 next.|pre_s|)
            (<= next.|pre_s| 1)))
      (= next.r state.r)
      (=
         next.ok4
         (and
            (<= 0 next.r)
            (<= next.r 1)))
      (=
         next.cex1
         (< next.w 6))
      (= next.|valof_pre_x| state.x)
      (ite
         state.|valof_arr:4:init|
         (= next.|valof_arr:4| 2)
         (= next.|valof_arr:4| next.|valof_pre_x|))
      (= next.|valof_arr:4:init| false)
      (ite
         state.|valof_arr:3:init|
         (= next.|valof_arr:3| 5)
         (= next.|valof_arr:3| 6))
      (= next.|valof_arr:3:init| false)
      (= next.|valof_pre_valof_arr:2| state.|valof_arr:3|)
      (ite
         state.|valof_arr:2:init|
         (= next.|valof_arr:2| 4)
         (= next.|valof_arr:2| next.|valof_pre_valof_arr:2|))
      (= next.|valof_arr:2:init| false)
      (= next.|valof_pre_valof_arr:1| state.|valof_arr:2|)
      (ite
         state.|valof_arr:1:init|
         (= next.|valof_arr:1| 3)
         (= next.|valof_arr:1| next.|valof_pre_valof_arr:1|))
      (= next.|valof_arr:1:init| false)
      (= next.|valof_pre_valof_arr| state.|valof_arr:1|)
      (ite
         state.|valof_arr:init|
         (= next.|valof_arr| 2)
         (= next.|valof_arr| next.|valof_pre_valof_arr|))
      (= next.|valof_arr:init| false)))

(query
   TS
   (or |gal-initializing| ok4))
(query
   TS
   (or |gal-initializing| ok3))
(query
   TS
   (or |gal-initializing| ok2))
(query
   TS
   (or |gal-initializing| cex1))
(query
   TS
   (or |gal-initializing| ok1))

[Lustre] Validating properties:
[Lustre] Property ok4... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
[[1;91mInvalid[0m] 
Trace
=====

ok4:
 Step | x | s | |-> 
------+---+---+-----
 1    | 0 | 0 |     

[Lustre] Property ok3... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
[[1;91mInvalid[0m] 
Trace
=====

ok3:
 Step | x | s | |-> 
------+---+---+-----
 1    | 0 | 0 |     

[Lustre] Property ok2... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
[[1;91mInvalid[0m] 
Trace
=====

ok2:
 Step | x | s | |-> 
------+---+---+-----
 1    | 0 | 0 |     

[Lustre] Property cex1... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
considering simultaneous states to depth 1
considering simultaneous states to depth 2
considering simultaneous states to depth 2
considering simultaneous states to depth 3
considering simultaneous states to depth 3
considering simultaneous states to depth 4
considering simultaneous states to depth 4
considering simultaneous states to depth 5
considering simultaneous states to depth 5
considering simultaneous states to depth 6
[[1;91mInvalid[0m] 
Trace
=====

cex1:
 Step | x | s | |-> 
------+---+---+-----
 1    | 0 | 0 |     
 2    | 0 | 0 |     
 3    | 0 | 0 |     
 4    | 0 | 0 |     
 5    | 0 | 0 |     
 6    | 0 | 0 |     

[Lustre] Property ok1... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
considering simultaneous states to depth 1
considering simultaneous states to depth 2
considering simultaneous states to depth 2
[[1;92mValid[0m] considering simultaneous states to depth 2
[Lustre] Model status: [[1;91mInvalid[0m] 
