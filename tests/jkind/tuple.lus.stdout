Core Lustre
===========

node (a : int, b : int, x : int, y : int)
  returns ()
  assumes (And)
  shows (ok3, cex2, ok2, cex1, ok1)
let
  min : int
    = ITE(Lt(a, b), a, b)
   
  max : int
    = ITE(Lt(a, b), b, a)
   
  pre_fib2 : int
    = pre fib2
   
  fib1 : int
    = 0 -> pre_fib2
   
  $pre : int
    = pre Add(fib1, fib2)
   
  fib2 : int
    = 1 -> $pre
   
  pre_toggle : bool
    = pre toggle
   
  toggle : bool
    = true -> Not(pre_toggle)
   
  diff$1 : int
    = 1
   
  pre_count_by_down$1 : int
    = pre count_by_down$1
   
  count_by_down$1 : int
    = 0 -> Sub(pre_count_by_down$1, diff$1)
   
  diff : int
    = 2
   
  pre_count_by_down : int
    = pre count_by_down
   
  count_by_down : int
    = 0 -> Sub(pre_count_by_down, diff)
   
  down : int
    = ITE(toggle, count_by_down$1, count_by_down)
   
  pre_count_by_up$1 : int
    = pre count_by_up$1
   
  count_by_up$1 : int
    = 0 -> Add(pre_count_by_up$1, diff$1)
   
  pre_count_by_up : int
    = pre count_by_up
   
  count_by_up : int
    = 0 -> Add(pre_count_by_up, diff)
   
  up : int
    = ITE(toggle, count_by_up$1, count_by_up)
   
  ok1 : bool
    = And(And(Leq(min, max), Or(Eq(a, min), Eq(a, max))), Or(Eq(b, min), Eq(b, max)))
   
  ok2 : bool
    = Neq(fib2, 10947)
   
  ok3 : bool
    = Or(And(Eq(x, 1), Eq(y, 2)), And(Eq(x, 3), Eq(y, 4)))
   
  cex1 : bool
    = Neq(fib2, 10946)
   
  cex2 : bool
    = Lt(up, 100)
   
  And : bool
    = And(Eq(x, ITE(toggle, 1, 3)), Eq(y, ITE(toggle, 2, 4)))
tel
Sally Model
===========

(define-state-type
   S
   (
     (And Bool)
     (a Int)
     (b Int)
     (cex1 Bool)
     (cex2 Bool)
     (diff Int)
     (down Int)
     (fib1 Int)
     (fib2 Int)
     (max Int)
     (min Int)
     (ok1 Bool)
     (ok2 Bool)
     (ok3 Bool)
     (toggle Bool)
     (up Int)
     (x Int)
     (y Int)
     (|$pre| Int)
     (|count_by_down:1:init| Bool)
     (|count_by_down:1| Int)
     (|count_by_down:init| Bool)
     (|count_by_down| Int)
     (|count_by_up:1:init| Bool)
     (|count_by_up:1| Int)
     (|count_by_up:init| Bool)
     (|count_by_up| Int)
     (|diff:1| Int)
     (|fib1:init| Bool)
     (|fib2:init| Bool)
     (|gal-initializing| Bool)
     (|pre_count_by_down:1| Int)
     (|pre_count_by_down| Int)
     (|pre_count_by_up:1| Int)
     (|pre_count_by_up| Int)
     (|pre_fib2| Int)
     (|pre_toggle| Bool)
     (|toggle:init| Bool))
   (
     (a Int)
     (b Int)
     (x Int)
     (y Int)))
(define-transition-system
   TS
   S
   (and
      (= |gal-initializing| true)
      (= |fib1:init| true)
      (= |fib2:init| true)
      (= |toggle:init| true)
      (= |count_by_down:1:init| true)
      (= |count_by_down:init| true)
      (= |count_by_up:1:init| true)
      (= |count_by_up:init| true))
   (and
      (= next.|gal-initializing| false)
      (= next.a input.a)
      (= next.b input.b)
      (= next.x input.x)
      (= next.y input.y)
      next.And
      (=
         next.min
         (ite
            (< next.a next.b)
            next.a
            next.b))
      (=
         next.max
         (ite
            (< next.a next.b)
            next.b
            next.a))
      (= next.|pre_fib2| state.fib2)
      (ite
         state.|fib1:init|
         (= next.fib1 0)
         (= next.fib1 next.|pre_fib2|))
      (= next.|fib1:init| false)
      (=
         next.|$pre|
         (+ state.fib1 state.fib2))
      (ite
         state.|fib2:init|
         (= next.fib2 1)
         (= next.fib2 next.|$pre|))
      (= next.|fib2:init| false)
      (= next.|pre_toggle| state.toggle)
      (ite
         state.|toggle:init|
         (= next.toggle true)
         (=
            next.toggle
            (not next.|pre_toggle|)))
      (= next.|toggle:init| false)
      (= next.|diff:1| 1)
      (= next.|pre_count_by_down:1| state.|count_by_down:1|)
      (ite
         state.|count_by_down:1:init|
         (= next.|count_by_down:1| 0)
         (=
            next.|count_by_down:1|
            (- next.|pre_count_by_down:1| next.|diff:1|)))
      (= next.|count_by_down:1:init| false)
      (= next.diff 2)
      (= next.|pre_count_by_down| state.|count_by_down|)
      (ite
         state.|count_by_down:init|
         (= next.|count_by_down| 0)
         (=
            next.|count_by_down|
            (- next.|pre_count_by_down| next.diff)))
      (= next.|count_by_down:init| false)
      (=
         next.down
         (ite next.toggle next.|count_by_down:1| next.|count_by_down|))
      (= next.|pre_count_by_up:1| state.|count_by_up:1|)
      (ite
         state.|count_by_up:1:init|
         (= next.|count_by_up:1| 0)
         (=
            next.|count_by_up:1|
            (+ next.|pre_count_by_up:1| next.|diff:1|)))
      (= next.|count_by_up:1:init| false)
      (= next.|pre_count_by_up| state.|count_by_up|)
      (ite
         state.|count_by_up:init|
         (= next.|count_by_up| 0)
         (=
            next.|count_by_up|
            (+ next.|pre_count_by_up| next.diff)))
      (= next.|count_by_up:init| false)
      (=
         next.up
         (ite next.toggle next.|count_by_up:1| next.|count_by_up|))
      (=
         next.ok1
         (and
            (<= next.min next.max)
            (or
               (= next.a next.min)
               (= next.a next.max))
            (or
               (= next.b next.min)
               (= next.b next.max))))
      (=
         next.ok2
         (not
            (= next.fib2 10947)))
      (=
         next.ok3
         (or
            (and
               (= next.x 1)
               (= next.y 2))
            (and
               (= next.x 3)
               (= next.y 4))))
      (=
         next.cex1
         (not
            (= next.fib2 10946)))
      (=
         next.cex2
         (< next.up 100))
      (=
         next.And
         (and
            (=
               next.x
               (ite next.toggle 1 3))
            (=
               next.y
               (ite next.toggle 2 4))))))

(query
   TS
   (or |gal-initializing| ok3))
(query
   TS
   (or |gal-initializing| cex2))
(query
   TS
   (or |gal-initializing| ok2))
(query
   TS
   (or |gal-initializing| cex1))
(query
   TS
   (or |gal-initializing| ok1))

[Lustre] Validating properties:
[Lustre] Property ok3... considering simultaneous states to depth 0
considering simultaneous states to depth 0
[Valid] considering simultaneous states to depth 0
[Lustre] Property cex2... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
considering simultaneous states to depth 1
considering simultaneous states to depth 2
considering simultaneous states to depth 2
considering simultaneous states to depth 3
considering simultaneous states to depth 3
considering simultaneous states to depth 4
considering simultaneous states to depth 4
considering simultaneous states to depth 5
considering simultaneous states to depth 5
considering simultaneous states to depth 6
considering simultaneous states to depth 6
considering simultaneous states to depth 7
considering simultaneous states to depth 7
considering simultaneous states to depth 8
considering simultaneous states to depth 8
considering simultaneous states to depth 9
considering simultaneous states to depth 9
considering simultaneous states to depth 10
considering simultaneous states to depth 10
counter-example search depth 0
counter-example search depth 1
counter-example search depth 2
counter-example search depth 3
counter-example search depth 4
counter-example search depth 5
counter-example search depth 6
counter-example search depth 7
counter-example search depth 8
counter-example search depth 9
counter-example search depth 10
[Unknown] Valid up to depth 10
[Lustre] Property ok2... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
considering simultaneous states to depth 1
considering simultaneous states to depth 2
considering simultaneous states to depth 2
considering simultaneous states to depth 3
considering simultaneous states to depth 3
considering simultaneous states to depth 4
considering simultaneous states to depth 4
considering simultaneous states to depth 5
considering simultaneous states to depth 5
considering simultaneous states to depth 6
considering simultaneous states to depth 6
considering simultaneous states to depth 7
considering simultaneous states to depth 7
considering simultaneous states to depth 8
considering simultaneous states to depth 8
considering simultaneous states to depth 9
considering simultaneous states to depth 9
considering simultaneous states to depth 10
considering simultaneous states to depth 10
counter-example search depth 0
counter-example search depth 1
counter-example search depth 2
counter-example search depth 3
counter-example search depth 4
counter-example search depth 5
counter-example search depth 6
counter-example search depth 7
counter-example search depth 8
counter-example search depth 9
counter-example search depth 10
[Unknown] Valid up to depth 10
[Lustre] Property cex1... considering simultaneous states to depth 0
considering simultaneous states to depth 0
considering simultaneous states to depth 1
considering simultaneous states to depth 1
considering simultaneous states to depth 2
considering simultaneous states to depth 2
considering simultaneous states to depth 3
considering simultaneous states to depth 3
considering simultaneous states to depth 4
considering simultaneous states to depth 4
considering simultaneous states to depth 5
considering simultaneous states to depth 5
considering simultaneous states to depth 6
considering simultaneous states to depth 6
considering simultaneous states to depth 7
considering simultaneous states to depth 7
considering simultaneous states to depth 8
considering simultaneous states to depth 8
considering simultaneous states to depth 9
considering simultaneous states to depth 9
considering simultaneous states to depth 10
considering simultaneous states to depth 10
counter-example search depth 0
counter-example search depth 1
counter-example search depth 2
counter-example search depth 3
counter-example search depth 4
counter-example search depth 5
counter-example search depth 6
counter-example search depth 7
counter-example search depth 8
counter-example search depth 9
counter-example search depth 10
[Unknown] Valid up to depth 10
[Lustre] Property ok1... considering simultaneous states to depth 0
considering simultaneous states to depth 0
[Valid] considering simultaneous states to depth 0
[Lustre] Model status: [Unknown] 
